{"ast":null,"code":"import Cookies from 'js-cookie';\nexport function removeCSSClass(ele, cls) {\n  const reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n  ele.className = ele.className.replace(reg, ' ');\n}\nexport function addCSSClass(ele, cls) {\n  ele.classList.add(cls);\n}\nexport const toAbsoluteUrl = pathname => process.env.PUBLIC_URL + pathname;\nexport const roundNumberToTwoDecimals = value => {\n  return Math.round(value * 100) / 100;\n}; // export function setupAxios(axios, store) {\n// \taxios.interceptors.request.use(\n// \t\tconfig => {\n// \t\t\tconst {\n// \t\t\t\tauth: { authToken },\n// \t\t\t} = store.getState();\n// \t\t\tif (authToken) {\n// \t\t\t\tconfig.headers.Authorization = `Bearer ${authToken}`;\n// \t\t\t}\n// \t\t\treturn config;\n// \t\t},\n// \t\terr => Promise.reject(err),\n// \t);\n// }\n\n/*  removeStorage: removes a key from localStorage and its sibling expiracy key\n    params:\n        key <string>     : localStorage key to remove\n    returns:\n        <boolean> : telling if operation succeeded\n */\n\nexport function removeStorage(key) {\n  try {\n    localStorage.setItem(key, '');\n    localStorage.setItem(key + '_expiresIn', '');\n  } catch (e) {\n    console.log('removeStorage: Error removing key [' + key + '] from localStorage: ' + JSON.stringify(e));\n    return false;\n  }\n\n  return true;\n}\n/*  getStorage: retrieves a key from localStorage previously set with setStorage().\n    params:\n        key <string> : localStorage key\n    returns:\n        <string> : value of localStorage key\n        null : in case of expired key or failure\n */\n\nexport function getStorage(key) {\n  const now = Date.now(); //epoch time, lets deal only with integer\n  // set expiration for storage\n\n  let expiresIn = localStorage.getItem(key + '_expiresIn');\n\n  if (expiresIn === undefined || expiresIn === null) {\n    expiresIn = 0;\n  }\n\n  expiresIn = Math.abs(expiresIn);\n\n  if (expiresIn < now) {\n    // Expired\n    removeStorage(key);\n    return null;\n  } else {\n    try {\n      const value = localStorage.getItem(key);\n      return value;\n    } catch (e) {\n      console.log('getStorage: Error reading key [' + key + '] from localStorage: ' + JSON.stringify(e));\n      return null;\n    }\n  }\n}\n/*  setStorage: writes a key into localStorage setting a expire time\n    params:\n        key <string>     : localStorage key\n        value <string>   : localStorage value\n        expires <number> : number of seconds from now to expire the key\n    returns:\n        <boolean> : telling if operation succeeded\n */\n\nexport function setStorage(key, value, expires) {\n  if (expires === undefined || expires === null) {\n    expires = 24 * 60 * 60; // default: seconds for 1 day\n  }\n\n  const now = Date.now(); //millisecs since epoch time, lets deal only with integer\n\n  const schedule = now + expires * 1000;\n\n  try {\n    localStorage.setItem(key, value);\n    localStorage.setItem(key + '_expiresIn', schedule);\n  } catch (e) {\n    console.log('setStorage: Error setting key [' + key + '] in localStorage: ' + JSON.stringify(e));\n    return false;\n  }\n\n  return true;\n}\nlet authToken = '';\n/**\n * Set Token\n * @param token\n */\n\nexport const setToken = async (token, expireIn = 7) => {\n  try {\n    authToken = token ? `${token}` : '';\n    localStorage.setItem('accessToken', authToken, {\n      expires: expireIn\n    });\n  } catch (error) {\n    console.log(error);\n  }\n};\n/**\n * Get Token & Set Token In Request\n */\n\nexport const getToken = () => {\n  try {\n    const token = localStorage.getItem('accessToken');\n    authToken = token ? token : '';\n    return authToken;\n  } catch (error) {\n    console.log(error);\n  }\n};\n/**\n * Input: Number\n * Output: ABCDEFG\n */\n\nexport const incrementAlphabet = int => {\n  return String.fromCharCode(65 + int);\n};\n/**\n * Input: QuestionSections\n * Count questions in question sections and put them as strings to display\n * Output: {'1-5', '6-13', '14-24'}\n */\n\nexport const getQuestionSectionQuestionRange = (questionSections, startingNumber = 1) => {\n  let questionRange = [];\n  let currentEnd = startingNumber;\n  console.log(startingNumber);\n  questionSections.map((questionSection, idx) => {\n    // if (idx === 0) {\n    // \tcurrentEnd = 1;\n    // }\n    const start = currentEnd;\n    const end = questionSection.questions.length + start - 1;\n    currentEnd = currentEnd + questionSection.questions.length;\n    questionRange.push(`${start}-${end}`);\n  });\n  console.log(questionRange);\n  return questionRange;\n};\n/**\n * Input: Passages\n * Count questions in passages and put them as strings to display\n * Output: {'1-13', '14-26', '26-40'}\n */\n\nexport const getPassageQuestionRange = passages => {\n  let questionRange = [];\n  let currentEnd;\n  passages.map((passage, idx) => {\n    let passageQuestionAmount;\n    passage.questionSections.map((questionSection, idx) => {\n      if (idx === 0) {\n        passageQuestionAmount = 0;\n      }\n\n      passageQuestionAmount = passageQuestionAmount + questionSection.questions.length;\n    });\n\n    if (idx === 0) {\n      currentEnd = 1;\n    }\n\n    const start = currentEnd;\n    const end = passageQuestionAmount + start - 1;\n    currentEnd = currentEnd + passageQuestionAmount;\n    questionRange.push(`${start}-${end}`);\n  });\n  return questionRange;\n};\n/**\n * Input: Int\n * Output: true / false\n */\n\nexport function isEven(value) {\n  if (value % 2 == 0) return true;else return false;\n}\n/**\n * Get ending number as the next starting number for the passage questionRange\n * Ex: passage 1: 1-13 -> passage 2: 13 + 1 - x\n * Input: String\n * Output: Int\n */\n\nexport function getEndingNumber(value) {\n  const getNumber = value.substr(value.indexOf('-') + 1, value.length);\n  const returnNumber = parseInt(getNumber);\n  return returnNumber;\n}\n/**\n * Input: Int\n * Output: true / false\n */\n\nexport function questionIndexing(questionRange) {\n  const getNumber = questionRange.substr(0, questionRange.indexOf('-'));\n  const startIndex = parseInt(getNumber) - 1;\n  return startIndex;\n}\n/**\n * Used in spliting question content in fill in the gap question\n * Detects the gap by finding [BLANK] in the string and split it into two sides of string\n * Then put an input in between\n * Input: String\n * Output: Two strings without [BLANK]: {leftString: \"\", rightString: \"\"}\n */\n\nexport function splitStringByBlank(string) {\n  const searchTerm = '[BLANK]';\n  const searchTermLength = searchTerm.length;\n  const findBlank = string.indexOf(searchTerm);\n  const leftString = string.substring(0, findBlank);\n  const rightString = string.substring(findBlank + searchTermLength, string.length);\n  return {\n    leftString: leftString,\n    rightString: rightString\n  };\n}\n/**\n * Input: Milliseconds\n * Output: minutes : seconds\n */\n\nexport function msToTime(millis) {\n  var minutes = Math.floor(millis / 60000);\n  var seconds = (millis % 60000 / 1000).toFixed(0);\n  return minutes + ':' + (seconds < 10 ? '0' : '') + seconds;\n} // Used for strings contains special characters to refine for later input\n// and data storage\n\nexport function EscapeQuotationMarks(string) {\n  var goodQuotes = string.replace(/[\\u2018\\u2019]/g, \"'\").replace(/[\\u201C\\u201D]/g, '\"').replace(/(?:\\r\\n|\\r|\\n)/g, '\\n');\n  return goodQuotes;\n} // Used to read image and export to base64\n\nexport async function convertToBase64(file) {\n  let reader = new FileReader();\n  await reader.readAsDataURL(file);\n  return reader;\n\n  reader.onloadend = () => {\n    return reader.result;\n  };\n} // Shallow equal two objects\n// Compare two objects\n\nexport function objectShallowEqual(object1, object2) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let key of keys1) {\n    if (object1[key] !== object2[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/nus/TuTran/projects/Web/training/photobook/FE/src/utils/utils.js"],"names":["Cookies","removeCSSClass","ele","cls","reg","RegExp","className","replace","addCSSClass","classList","add","toAbsoluteUrl","pathname","process","env","PUBLIC_URL","roundNumberToTwoDecimals","value","Math","round","removeStorage","key","localStorage","setItem","e","console","log","JSON","stringify","getStorage","now","Date","expiresIn","getItem","undefined","abs","setStorage","expires","schedule","authToken","setToken","token","expireIn","error","getToken","incrementAlphabet","int","String","fromCharCode","getQuestionSectionQuestionRange","questionSections","startingNumber","questionRange","currentEnd","map","questionSection","idx","start","end","questions","length","push","getPassageQuestionRange","passages","passage","passageQuestionAmount","isEven","getEndingNumber","getNumber","substr","indexOf","returnNumber","parseInt","questionIndexing","startIndex","splitStringByBlank","string","searchTerm","searchTermLength","findBlank","leftString","substring","rightString","msToTime","millis","minutes","floor","seconds","toFixed","EscapeQuotationMarks","goodQuotes","convertToBase64","file","reader","FileReader","readAsDataURL","onloadend","result","objectShallowEqual","object1","object2","keys1","Object","keys","keys2"],"mappings":"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","sourcesContent":["import Cookies from 'js-cookie';\n\nexport function removeCSSClass(ele, cls) {\n\tconst reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n\tele.className = ele.className.replace(reg, ' ');\n}\n\nexport function addCSSClass(ele, cls) {\n\tele.classList.add(cls);\n}\n\nexport const toAbsoluteUrl = pathname => process.env.PUBLIC_URL + pathname;\n\nexport const roundNumberToTwoDecimals = value => {\n\treturn Math.round(value * 100) / 100;\n};\n\n// export function setupAxios(axios, store) {\n// \taxios.interceptors.request.use(\n// \t\tconfig => {\n// \t\t\tconst {\n// \t\t\t\tauth: { authToken },\n// \t\t\t} = store.getState();\n\n// \t\t\tif (authToken) {\n// \t\t\t\tconfig.headers.Authorization = `Bearer ${authToken}`;\n// \t\t\t}\n\n// \t\t\treturn config;\n// \t\t},\n// \t\terr => Promise.reject(err),\n// \t);\n// }\n\n/*  removeStorage: removes a key from localStorage and its sibling expiracy key\n    params:\n        key <string>     : localStorage key to remove\n    returns:\n        <boolean> : telling if operation succeeded\n */\nexport function removeStorage(key) {\n\ttry {\n\t\tlocalStorage.setItem(key, '');\n\t\tlocalStorage.setItem(key + '_expiresIn', '');\n\t} catch (e) {\n\t\tconsole.log('removeStorage: Error removing key [' + key + '] from localStorage: ' + JSON.stringify(e));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/*  getStorage: retrieves a key from localStorage previously set with setStorage().\n    params:\n        key <string> : localStorage key\n    returns:\n        <string> : value of localStorage key\n        null : in case of expired key or failure\n */\nexport function getStorage(key) {\n\tconst now = Date.now(); //epoch time, lets deal only with integer\n\t// set expiration for storage\n\tlet expiresIn = localStorage.getItem(key + '_expiresIn');\n\tif (expiresIn === undefined || expiresIn === null) {\n\t\texpiresIn = 0;\n\t}\n\n\texpiresIn = Math.abs(expiresIn);\n\tif (expiresIn < now) {\n\t\t// Expired\n\t\tremoveStorage(key);\n\t\treturn null;\n\t} else {\n\t\ttry {\n\t\t\tconst value = localStorage.getItem(key);\n\t\t\treturn value;\n\t\t} catch (e) {\n\t\t\tconsole.log('getStorage: Error reading key [' + key + '] from localStorage: ' + JSON.stringify(e));\n\t\t\treturn null;\n\t\t}\n\t}\n}\n/*  setStorage: writes a key into localStorage setting a expire time\n    params:\n        key <string>     : localStorage key\n        value <string>   : localStorage value\n        expires <number> : number of seconds from now to expire the key\n    returns:\n        <boolean> : telling if operation succeeded\n */\nexport function setStorage(key, value, expires) {\n\tif (expires === undefined || expires === null) {\n\t\texpires = 24 * 60 * 60; // default: seconds for 1 day\n\t}\n\n\tconst now = Date.now(); //millisecs since epoch time, lets deal only with integer\n\tconst schedule = now + expires * 1000;\n\ttry {\n\t\tlocalStorage.setItem(key, value);\n\t\tlocalStorage.setItem(key + '_expiresIn', schedule);\n\t} catch (e) {\n\t\tconsole.log('setStorage: Error setting key [' + key + '] in localStorage: ' + JSON.stringify(e));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nlet authToken = '';\n\n/**\n * Set Token\n * @param token\n */\nexport const setToken = async (token, expireIn = 7) => {\n\ttry {\n\t\tauthToken = token ? `${token}` : '';\n\t\tlocalStorage.setItem('accessToken', authToken, { expires: expireIn });\n\t} catch (error) {\n\t\tconsole.log(error);\n\t}\n};\n\n/**\n * Get Token & Set Token In Request\n */\nexport const getToken = () => {\n\ttry {\n\t\tconst token = localStorage.getItem('accessToken');\n\t\tauthToken = token ? token : '';\n\t\treturn authToken;\n\t} catch (error) {\n\t\tconsole.log(error);\n\t}\n};\n\n/**\n * Input: Number\n * Output: ABCDEFG\n */\n\nexport const incrementAlphabet = int => {\n\treturn String.fromCharCode(65 + int);\n};\n\n/**\n * Input: QuestionSections\n * Count questions in question sections and put them as strings to display\n * Output: {'1-5', '6-13', '14-24'}\n */\n\nexport const getQuestionSectionQuestionRange = (questionSections, startingNumber = 1) => {\n\tlet questionRange = [];\n\tlet currentEnd = startingNumber;\n\tconsole.log(startingNumber);\n\n\tquestionSections.map((questionSection, idx) => {\n\t\t// if (idx === 0) {\n\t\t// \tcurrentEnd = 1;\n\t\t// }\n\t\tconst start = currentEnd;\n\t\tconst end = questionSection.questions.length + start - 1;\n\t\tcurrentEnd = currentEnd + questionSection.questions.length;\n\t\tquestionRange.push(`${start}-${end}`);\n\t});\n\tconsole.log(questionRange);\n\treturn questionRange;\n};\n\n/**\n * Input: Passages\n * Count questions in passages and put them as strings to display\n * Output: {'1-13', '14-26', '26-40'}\n */\n\nexport const getPassageQuestionRange = passages => {\n\tlet questionRange = [];\n\tlet currentEnd;\n\n\tpassages.map((passage, idx) => {\n\t\tlet passageQuestionAmount;\n\n\t\tpassage.questionSections.map((questionSection, idx) => {\n\t\t\tif (idx === 0) {\n\t\t\t\tpassageQuestionAmount = 0;\n\t\t\t}\n\t\t\tpassageQuestionAmount = passageQuestionAmount + questionSection.questions.length;\n\t\t});\n\n\t\tif (idx === 0) {\n\t\t\tcurrentEnd = 1;\n\t\t}\n\n\t\tconst start = currentEnd;\n\t\tconst end = passageQuestionAmount + start - 1;\n\t\tcurrentEnd = currentEnd + passageQuestionAmount;\n\t\tquestionRange.push(`${start}-${end}`);\n\t});\n\n\treturn questionRange;\n};\n\n/**\n * Input: Int\n * Output: true / false\n */\nexport function isEven(value) {\n\tif (value % 2 == 0) return true;\n\telse return false;\n}\n\n/**\n * Get ending number as the next starting number for the passage questionRange\n * Ex: passage 1: 1-13 -> passage 2: 13 + 1 - x\n * Input: String\n * Output: Int\n */\nexport function getEndingNumber(value) {\n\tconst getNumber = value.substr(value.indexOf('-') + 1, value.length);\n\tconst returnNumber = parseInt(getNumber);\n\treturn returnNumber;\n}\n\n/**\n * Input: Int\n * Output: true / false\n */\nexport function questionIndexing(questionRange) {\n\tconst getNumber = questionRange.substr(0, questionRange.indexOf('-'));\n\tconst startIndex = parseInt(getNumber) - 1;\n\treturn startIndex;\n}\n\n/**\n * Used in spliting question content in fill in the gap question\n * Detects the gap by finding [BLANK] in the string and split it into two sides of string\n * Then put an input in between\n * Input: String\n * Output: Two strings without [BLANK]: {leftString: \"\", rightString: \"\"}\n */\n\nexport function splitStringByBlank(string) {\n\tconst searchTerm = '[BLANK]';\n\tconst searchTermLength = searchTerm.length;\n\tconst findBlank = string.indexOf(searchTerm);\n\tconst leftString = string.substring(0, findBlank);\n\tconst rightString = string.substring(findBlank + searchTermLength, string.length);\n\treturn {\n\t\tleftString: leftString,\n\t\trightString: rightString,\n\t};\n}\n\n/**\n * Input: Milliseconds\n * Output: minutes : seconds\n */\nexport function msToTime(millis) {\n\tvar minutes = Math.floor(millis / 60000);\n\tvar seconds = ((millis % 60000) / 1000).toFixed(0);\n\treturn minutes + ':' + (seconds < 10 ? '0' : '') + seconds;\n}\n\n// Used for strings contains special characters to refine for later input\n// and data storage\nexport function EscapeQuotationMarks(string) {\n\tvar goodQuotes = string\n\t\t.replace(/[\\u2018\\u2019]/g, \"'\")\n\t\t.replace(/[\\u201C\\u201D]/g, '\"')\n\t\t.replace(/(?:\\r\\n|\\r|\\n)/g, '\\n');\n\treturn goodQuotes;\n}\n\n// Used to read image and export to base64\nexport async function convertToBase64(file) {\n\tlet reader = new FileReader();\n\tawait reader.readAsDataURL(file);\n\treturn reader;\n\treader.onloadend = () => {\n\t\treturn reader.result;\n\t};\n}\n\n// Shallow equal two objects\n// Compare two objects\n\nexport function objectShallowEqual(object1, object2) {\n\tconst keys1 = Object.keys(object1);\n\tconst keys2 = Object.keys(object2);\n\n\tif (keys1.length !== keys2.length) {\n\t\treturn false;\n\t}\n\n\tfor (let key of keys1) {\n\t\tif (object1[key] !== object2[key]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"]},"metadata":{},"sourceType":"module"}